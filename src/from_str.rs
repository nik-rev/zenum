#[macro_export]
macro_rules! FromStr {
    derive() (
        // <enum_parse: start> NOTE: generated by `generate.rs`
        $(#[$($enum_attr:tt)*])*
        $enum_vis:vis enum $enum_ident:ident
            // a best-effort parsing of generics
            //
            // what's missing:
            //
            // - more than 1 lifetime bound (e.g. 'a: 'b + 'c)
            // - more than 1 trait bound (e.g. T: A + B + C)
            // - support for "use" TypeParam in trait bounds
            // - `const` type parameters are totally unsupported
            // - `for<..>` lifetimes in `where` clause
            $(<
                $(
                    $(#[$($type_param_attr:tt)*])*
                    // lifetime parameter
                    $($type_param_lifetime:lifetime $(: $type_param_lifetime_super:lifetime)?)?
                    // type parameter
                    $($type_param_type:ident
                        $(:
                            $($type_param_lifetime_bound:lifetime)?
                            $($type_param_type_bound:path)?
                        )? $(= $type_param_default:ty)?
                    )?
                ),*
                $(,)?
            >)?
            $(where $(
                $($where_lifetime:lifetime: $where_lifetime_bounds:lifetime)?
                $($where_type_param_ty:ty: $where_type_param_bounds:path)?
            ),*)?
        {
            $(
                $(#[$($enum_variant_attr:tt)*])*
                $enum_variant:ident
                    // enum with named fields
                    $({
                        $(
                            $(#[$($enum_variant_named_field_attr:tt)*])*
                            $enum_variant_named_field_ident:ident: $enum_variant_named_field_ty:ty
                        ),* $(,)?
                    })?
                    // enum with unnamed fields
                    $((
                        $(
                            $(#[$($enum_variant_unnamed_field_attr:tt)*])*
                            $enum_variant_unnamed_field_ty:ty
                        ),* $(,)?
                    ))?
                    // discriminant
                    $(= $enum_variant_discriminant:expr)?
            ),* $(,)?
        }
        // <enum_parse: end>
    ) => {
        impl ::core::str::FromStr for $enum_ident {
            type Err = ();

            fn from_str(s: &::core::primitive::str) -> ::core::result::Result<Self, Self::Err> {
                // Get this:
                //
                // #[zenum(rename_all = "...")]
                //                      ^^^^^
                const RENAME_ALL: Option<$crate::Case> =
                    $crate::get_macro_helper_value_for_enum!(,rename_all: $(#[$($enum_attr)*])*);

                // Check if this is present:
                //
                // #[zenum(ascii_case_insensitive)]
                //         ^^^^^^^^^^^^^^^^^^^^^^
                const IS_ENUM_CASE_INSENSITIVE: bool =
                    $crate::private::identity::<Option<()>>(
                        $crate::get_macro_helper_value_for_enum!(,case_insensitive: $(#[$($enum_attr)*])*)
                    ).is_some();

                // Prefix to prepend to all variants
                const PREFIX: &str = {
                    let prefix: Option<&str> = $crate::get_macro_helper_value_for_enum!(,prefix: $(#[$($enum_attr)*])*);
                    if let Some(prefix) = prefix {
                        prefix
                    } else {
                        ""
                    }
                };

                // Suffix to append to all variants
                const SUFFIX: &str = {
                    let suffix: Option<&str> = $crate::get_macro_helper_value_for_enum!(,suffix: $(#[$($enum_attr)*])*);
                    if let Some(suffix) = suffix {
                        suffix
                    } else {
                        ""
                    }
                };

                // Suffix to append to all variants
                const ALIASES: &[&str] = {
                    let suffix: Option<&[&str]> = $crate::get_macro_helper_value_for_enum!(FromStr, aliases: $(#[$($enum_attr)*])*);
                    if let Some(suffix) = suffix {
                        suffix
                    } else {
                        &[]
                    }
                };

                $(
                    #[allow(non_upper_case_globals)]
                    const $enum_variant: $crate::private::EnumVariantData = {
                        // Get this:
                        //
                        // #[zenum(rename = "...")]
                        //                  ^^^^^
                        const RENAME: Option<&str> = $crate::get_macro_helper_value_for_variant!(,rename: $(#[$($enum_variant_attr)*])*);

                        // actual string representation of the enum variant
                        const NAME: &str = if RENAME.is_some() {
                            // supplied #[zenum(rename = "...")], overrides #[zenum(rename_all = "...")]

                            // #[zenum(suffix)] and #[zenum(prefix)] are NOT considered, since we have
                            // specifically overridden this variant's serialization/deserialization
                            $crate::__hacky_unwrap!(RENAME, HACK = "")
                        } else if RENAME_ALL.is_some() {
                            // supplied #[zenum(rename_all = "...")]
                            const NAME: &str = $crate::map_ascii_case!(
                                $crate::__hacky_unwrap!(RENAME_ALL, HACK = $crate::Case::Lower),
                                stringify!($enum_ident)
                            );
                            // We add suffix/prefix only AFTER applying the case rename rule
                            $crate::private::const_str::concat!(PREFIX, NAME, SUFFIX)
                        } else {
                            // default to stringified name of the enum variant if neither #[zenum(rename)]
                            // or #[zenum(rename_all)] are supplied
                            $crate::private::const_str::concat!(PREFIX, stringify!($enum_ident), SUFFIX)
                        };

                        // if this enum is disabled, we won't generate any code for it
                        const IS_DISABLED: Option<()> = $crate::get_macro_helper_value_for_variant!(,skip: $(#[$($enum_variant_attr)*])*);
                        const IS_VARIANT_CASE_INSENSITIVE: Option<()> = $crate::get_macro_helper_value_for_variant!(,case_insensitive: $(#[$($enum_variant_attr)*])*);
                        const IS_VARIANT_CASE_INSENSITIVE_2: bool = IS_VARIANT_CASE_INSENSITIVE.is_some();
                        const IS_CASE_INSENSITIVE: bool = IS_VARIANT_CASE_INSENSITIVE_2 || IS_ENUM_CASE_INSENSITIVE;

                        $crate::private::EnumVariantData {
                            stringified_name: NAME_2,
                            is_disabled: IS_DISABLED.is_some(),
                            is_case_insensitive: IS_CASE_INSENSITIVE,
                            is_ascii: NAME_2.is_ascii()
                        }
                    };
                )*

                match s {
                    $(
                        v
                        // check that the 2 strings are equal
                        if (if $enum_variant.is_case_insensitive {
                            if $enum_variant.is_ascii {
                                // Ascii case-insensitive comparison (cheaper)
                                v.to_ascii_lowercase() == const { $crate::map_ascii_case!($crate::Case::Lower, $enum_variant.stringified_name) }
                            } else {
                                // Full unicode case-insensitive comparison (more expensive)
                                v.to_lowercase() == $enum_variant.stringified_name.to_lowercase()
                            }
                        } else {
                            v == $enum_variant.stringified_name
                        })
                        // not #[zenum(skip)] or #[zenum(skip(FromStr))]
                        && !$enum_variant.is_disabled => Ok(Self::$enum_variant
                            // enum with named fields
                            $({
                                $(
                                    $enum_variant_named_field_ident:
                                    <$enum_variant_named_field_ty as ::core::default::Default>::default(),
                                )*
                            })?
                            // enum with unnamed fields
                            $((
                                $(
                                    <$enum_variant_unnamed_field_ty as ::core::default::Default>::default(),
                                )*
                            ))?
                        ),
                    )*
                    _ => Err(())
                }
            }
        }
    };
}

pub struct EnumVariantData {
    pub stringified_name: &'static str,
    pub is_disabled: bool,
    pub is_case_insensitive: bool,
    pub is_ascii: bool,
}
